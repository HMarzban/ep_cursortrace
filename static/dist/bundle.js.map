{"version":3,"file":"bundle.js","sources":["../js/index.js"],"sourcesContent":["'use strict';\n\nlet initiated = false;\nlet last = undefined;\nlet globalKey = 0;\n\nconst htmlSubstr = (str, count) => {\n  const div = document.createElement('div');\n  div.innerHTML = str;\n\n  const track = (el) => {\n    if (count > 0) {\n      const len = el.data.length;\n      count -= len;\n      if (count <= 0) {\n        el.data = el.substringData(0, el.data.length + count);\n      }\n    } else {\n      el.data = '';\n    }\n  };\n\n  const walk = (el, fn) => {\n    let node = el.firstChild;\n    if (!node) return;\n    do {\n      if (node.nodeType === 3) {\n        fn(node);\n        //          Added this >>------------------------------------<<\n      } else if (node.nodeType === 1 && node.childNodes && node.childNodes[0]) {\n        walk(node, fn);\n      }\n    } while (node = node.nextSibling); /* eslint-disable-line no-cond-assign */\n  };\n  walk(div, track);\n  return div.innerHTML;\n};\n\nconst wrap = (target) => {\n  const newtarget = $('<div></div>');\n  const nodes = target.contents().clone(); // the clone is critical!\n  if (!nodes) return;\n  nodes.each(function () {\n    if (this.nodeType === 3) { // text\n      let newhtml = '';\n      const text = this.wholeText; // maybe \"textContent\" is better?\n      for (let i = 0; i < text.length; i++) {\n        if (text[i] === ' ') {\n          newhtml += `<span data-key=${globalKey}> </span>`;\n        } else {\n          newhtml += `<span data-key=${globalKey}>${text[i]}</span>`;\n        }\n        globalKey++;\n      }\n      newtarget.append($(newhtml));\n    } else { // recursion FTW!\n      // console.log(\"recursion\"); // IE handles recursion badly\n      $(this).html(wrap($(this))); // This really hurts doing any sort of count..\n      newtarget.append($(this));\n    }\n  });\n  return newtarget.html();\n};\n\nexport const aceEditorCSS = (hookName, cb) => ['/ep_cursortrace/static/css/cursortrace.css'];\n\nexport const aceInitInnerdocbodyHead = (hookName, args, cb) => {\n  const url = '../static/plugins/ep_cursortrace/static/css/ace_inner.css';\n  args.iframeHTML.push(`<link rel=\"stylesheet\" type=\"text/css\" href=\"${url}\"/>`);\n  cb();\n};\n\nexport const postAceInit = (hookName, args, cb) => {\n  initiated = true;\n\n  // create a limited doc pageview\n  const aceInner = $('iframe[name=\"ace_outer\"]').contents()\n      .find('iframe[name=\"ace_inner\"]').contents();\n\n  const innerhtml = aceInner.find('html');\n  const newIframe = aceInner.find('head link').clone(true); // clone stylesheet\n\n  let iframe = document.createElement('iframe');\n  iframe.id = 'inerDocMirror';\n  iframe = $(iframe).css({\n    'position': 'fixed',\n    'width': '100%',\n    'margin': 'auto',\n    'left': '50%',\n    'transform': 'translateX(-50%)',\n    'border': 'none',\n    'background': 'purple',\n    'z-index': '-999',\n    'opacity': '0',\n  });\n\n  innerhtml.prepend(iframe);\n  innerhtml.find('#inerDocMirror').contents().find('head').html(newIframe);\n  innerhtml.find('#inerDocMirror').contents().find('body').attr({\n    id: 'innerdocbody',\n    class: 'innerdocbody doesWrap ltr static',\n    style: 'overflow: hidden',\n  });\n\n  cb();\n};\n\nexport const getAuthorClassName = (author) => {\n  if (!author) return false;\n  const authorId = author.replace(/[^a-y0-9]/g, (c) => {\n    if (c === '.') return '-';\n    return `z${c.charCodeAt(0)}z`;\n  });\n  return `ep_real_time_chat-${authorId}`;\n};\n\nexport const className2Author = (className) => {\n  if (className.substring(0, 7) === 'author-') {\n    return className.substring(7).replace(/[a-y0-9]+|-|z.+?z/g, (cc) => {\n      if (cc === '-') { return '.'; } else if (cc.charAt(0) === 'z') {\n        return String.fromCharCode(Number(cc.slice(1, -1)));\n      } else {\n        return cc;\n      }\n    });\n  }\n};\n\nexport const aceEditEvent = (hookName, args) => {\n  // Note: last is a tri-state: undefined (when the pad is first loaded)\n  // null (no last cursor) and [line, col]\n  // The AceEditEvent because it usually applies to selected items and isn't\n  // really so mucha bout current position.\n  const caretMoving = ((args.callstack.editEvent.eventType === 'handleClick') ||\n      (args.callstack.type === 'handleKeyEvent') || (args.callstack.type === 'idleWorkTimer'));\n  if (caretMoving && initiated) { // Note that we have to use idle timer to get the mouse position\n    const Y = args.rep.selStart[0];\n    const X = args.rep.selStart[1];\n    if (!last || Y !== last[0] || X !== last[1]) { // If the position has changed\n      const myAuthorId = pad.getUserId();\n      const padId = pad.getPadId();\n      // Create a cursor position message to send to the server\n      const message = {\n        type: 'cursor',\n        action: 'cursorPosition',\n        locationY: Y,\n        locationX: X,\n        padId,\n        myAuthorId,\n      };\n      last = [];\n      last[0] = Y;\n      last[1] = X;\n\n      // console.log(\"Sent message\", message);\n      pad.collabClient.sendMessage(message); // Send the cursor position message to the server\n    }\n  }\n  return;\n};\n\nexport const handleClientMessage_CUSTOM = (hook, context, cb) => {\n  /* I NEED A REFACTOR, please */\n  // A huge problem with this is that it runs BEFORE the dom has\n  // been updated so edit events are always late..\n\n  const action = context.payload.action;\n  const authorId = context.payload.authorId;\n  if (pad.getUserId() === authorId) return false;\n  // Dont process our own caret position (yes we do get it..) -- This is not a bug\n  const authorClass = exports.getAuthorClassName(authorId);\n\n  const innerhtml = $('iframe[name=\"ace_outer\"]').contents().find('iframe').contents().find('html');\n  const inerDocMirror = innerhtml.find('#inerDocMirror').contents();\n\n  if (action === 'cursorPosition') {\n    // an author has sent this client a cursor position, we need to show it in the dom\n    let authorName = context.payload.authorName;\n    if (authorName === 'null' || authorName == null) {\n      // If the users username isn't set then display a smiley face\n      authorName = 'ðŸ˜Š';\n    }\n    // +1 as Etherpad line numbers start at 1\n    const y = context.payload.locationY + 1;\n    let x = context.payload.locationX;\n    let stickUp = false;\n\n    // Get the target Line\n    const div = $('iframe[name=\"ace_outer\"]').contents()\n        .find('iframe').contents().find('#innerdocbody').find(`div:nth-child(${y})`);\n\n    // Is the line visible yet?\n    if (div.length !== 0) {\n      let top = $(div).offset().top; // A standard generic offset\n      // The problem we have here is we don't know the px X offset of the caret from the user\n      // Because that's a blocker for now lets just put a nice little div on the left hand side..\n      // SO here is how we do this..\n      // Get the entire string including the styling\n      // Put it in a hidden SPAN that has the same width as ace inner\n      // Delete everything after X chars\n      // Measure the new width -- This gives us the offset without modifying the ACE Dom\n      // Due to IE sucking this doesn't work in IE....\n\n      // Get the HTML\n      const html = $(div).html();\n\n      // build an ugly ID, makes sense to use authorId as authorId's cursor can only exist once\n      const authorWorker = `hiddenUgly${exports.getAuthorClassName(authorId)}`;\n\n      // if Div contains block attribute IE h1 or H2 then increment by the number\n      // This is horrible but a limitation because I'm parsing HTML\n      if ($(div).children('span').length < 1) { x -= 1; }\n\n      // Get the new string but maintain mark up\n      const newText = htmlSubstr(html, x);\n\n      // A load of ugly HTML that can prolly be moved to CSS\n      const newLine = `\n        <span\n          style=\"display:block\"\n          id='${authorWorker}'\n          class='ghettoCursorXPos'\n        >\n         ${newText}\n        </span>\n      `;\n\n      // Set the globalKey to 0, we use this when we wrap the objects in a datakey\n      globalKey = 0; // It's bad, messy, don't ever develop like this.\n\n      // Add the HTML to the DOM\n      inerDocMirror.find('body').append(newLine);\n\n      // Get the worker element\n      const worker = inerDocMirror.find(`body #${authorWorker}`);\n\n      // Wrap the HTML in spans so we can find a char\n      $(worker).html(wrap($(worker), x));\n\n      // Get the Left offset of the x span\n      const span = $(worker).find('[data-key]').last();\n      const lastSpanHasChar = $(worker).find('span[class^=\\'author-\\']').find('[data-key]').last();\n      // Get the width of the element (This is how far out X is in px);\n      let left;\n      if (span.length !== 0) {\n        left = span.position().left;\n      } else {\n        // empty span.\n        left = 0;\n      }\n      if (lastSpanHasChar.length) {\n        left = lastSpanHasChar.position().left + lastSpanHasChar.width();\n      }\n\n      // Get the height of the element minus the inner line height\n      const height = worker.height(); // the height of the worker\n      top = (top + height) - (lastSpanHasChar.height());\n      // plus the top offset minus the actual height of our focus span\n      if (top <= 0) { // If the tooltip wont be visible to the user because it's too high up\n        stickUp = true;\n        top += (lastSpanHasChar.height() * 2);\n        if (top < 0) { top = 0; } // handle case where caret is in 0,0\n      }\n\n      const closectHeader = lastSpanHasChar.closest(':header');\n\n      // if the caret is in the heading line\n      if (closectHeader.length) {\n        top -= parseInt(closectHeader.css('marginTop'));\n        left += parseInt($(worker).parent().css('paddingLeft')) * 2;\n      }\n\n      // Remove the element\n      inerDocMirror.find(`body #${authorWorker}`).remove();\n\n      // Author color\n      const users = pad.collabClient.getConnectedUsers();\n      const outBody = $('iframe[name=\"ace_outer\"]').contents()\n          .find('iframe').contents().find('html');\n\n      $.each(users, (user, value) => {\n        if (value.userId === authorId) {\n          const colors = pad.getColorPalette(); // support non set colors\n          let color;\n          if (colors[value.colorId]) {\n            color = colors[value.colorId];\n          } else {\n            color = value.colorId; // Test for XSS\n          }\n\n          // Remove all divs that already exist for this author\n          outBody.find(`.caret-${authorClass}`).remove();\n\n          // Location of stick direction IE up or down\n          const location = stickUp ? 'stickUp' : 'stickDown';\n\n          // Create a new Div for this author\n          const $indicator = $(`\n            <div \n              class='caretindicator ${location} caret-${authorClass}'\n              style='height:16px;left:${left}px;top:${top}px;background-color:${color}'\n            >\n              <p class='stickp ${location}'></p>\n            </div>\n          `);\n          $indicator.attr('title', authorName);\n          $indicator.find('p').text(authorName);\n          $(outBody).append($indicator);\n\n          // After a while, fade it out :)\n          setTimeout(() => {\n            $indicator.fadeOut(500, () => {\n              $indicator.remove();\n            });\n          }, 2000);\n        }\n      });\n    }\n  }\n  return cb();\n};\n"],"names":["last","initiated","globalKey","wrap","target","newtarget","$","nodes","contents","clone","each","this","nodeType","newhtml","text","wholeText","i","length","append","html","exports","aceEditEvent","hookName","args","callstack","editEvent","eventType","type","Y","rep","selStart","X","myAuthorId","pad","getUserId","message","action","locationY","locationX","padId","getPadId","collabClient","sendMessage","aceEditorCSS","cb","aceInitInnerdocbodyHead","iframeHTML","push","className2Author","className","substring","replace","cc","charAt","String","fromCharCode","Number","slice","getAuthorClassName","author","c","charCodeAt","handleClientMessage_CUSTOM","hook","context","payload","authorId","authorClass","inerDocMirror","find","authorName","y","x","stickUp","div","top","offset","authorWorker","children","newText","str","count","document","createElement","innerHTML","walk","el","fn","node","firstChild","childNodes","nextSibling","len","data","substringData","htmlSubstr","newLine","worker","span","lastSpanHasChar","left","position","width","height","closectHeader","closest","parseInt","css","parent","remove","users","getConnectedUsers","outBody","user","value","userId","colors","getColorPalette","color","colorId","location","$indicator","attr","setTimeout","fadeOut","postAceInit","aceInner","innerhtml","newIframe","iframe","id","margin","transform","border","background","opacity","prepend","class","style"],"mappings":"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"}